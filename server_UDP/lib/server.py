import socket
import os
import sys
import json
import queue
import pickle
import time
import jsonpickle
import math

from threading import Thread, Lock

from lib import errors_provider as error
from lib.db.db_connection import DataBase
from lib.request_handler import RequestHandler
from lib.model.chunk import Chunk
from lib.model.client import Client
from lib.model.server_update import ServerUpdate
from lib.model.character import Character
from lib.package_threads import ReceivePackagesThread, SendPackagesThread

QUEUE_SIZE = 20
CHUNK_HEIGHT = 2160
CHUNK_WIDTH = 3840
CHARACTER_START_HEALTH = 100
CHARACTER_START_POSITION = (100, 100)
POS_X = 0
POS_Y = 1


class Server(Thread):

    object_id = 0

    def __init__(self):
        Thread.__init__(self)
        self.__IP_ADDRESS = None
        self.__PORT_NUMBER = None
        self.__MAX_HOSTS = None
        self.__MAX_PACKAGE = None
        self.__socket = None
        self.__received_packages = queue.Queue(QUEUE_SIZE)
        self.__packages_to_send = queue.Queue(QUEUE_SIZE)
        self.__connected_clients = []
        self.__config_file = 'config/server_config.json'
        self.__read_config()
        self.__db = DataBase()
        self.__bind_socket()
        self.__stopped = False
        self.__stop_signal_lock = Lock()
        self.__client_list_lock = Lock()
        self.__receiving_thread = ReceivePackagesThread(self.__socket, self.__received_packages, self.__MAX_PACKAGE)
        self.__receiving_thread.start()
        self.__sending_thread = SendPackagesThread(self.__socket, self.__packages_to_send)
        self.__sending_thread.start()
        self.__request_handler = RequestHandler(self)
        self.__map_height = 50000 # generated by server later
        self.__map_width = 50000 # generated by server later
        self.__chunks_list = []
        self.__create_chunks()
        self.__objects = []
        self.__clients_characters = []
        print('Server initialized')

    def get_client(self, address, auth_key):
        for client in self.__connected_clients:
            if client.get_address() == address and client.get_auth_key() == auth_key:
                return client
        return None

    def get_chunks_list(self):
        return self.__chunks_list

    def __get_next_id(self):
        self.object_id = self.object_id + 1
        return self.object_id

    def __create_chunks(self):
        pos_x = 0
        pos_y = 0
        while pos_y < self.__map_height:
            while pos_x < self.__map_width:
                self.__chunks_list.append(Chunk((pos_x + int(CHUNK_WIDTH / 2), pos_y + int(CHUNK_HEIGHT / 2))))
                pos_x = pos_x + CHUNK_WIDTH
            pos_x = 0
            pos_y = pos_y + CHUNK_HEIGHT
        print(self.__chunks_list.__len__())

    def stop(self):
        self.__stop_signal_lock.acquire()
        self.__stopped = True
        self.__stop_signal_lock.release()

    def run(self):
        while not self.__check_stop():
            self.__check_received_packages()
            self.__check_clients_activity()
            #self.__check_if_clients_need_update()
        self.__close_server()

    def __check_if_clients_need_update(self):
        need_update_clients = []
        for client in self.__connected_clients:
            if client.need_update():
                need_update_clients.append(client)
        for client in need_update_clients:
            self.__send_update_to_client(client)
            client.generate_next_update_time()

    def __send_update_to_client(self, client):
        update_data = []
        client_addr = client.get_address()
        client_auth_key = client.get_auth_key()
        client_character = client.get_client_character()
        for obj in self.get_close_objects(client_character):
            update_data.append(obj)
        for character in self.get_close_characters(client_character):
            update_data.append(character)
        package = ServerUpdate(client_auth_key, update_data)
        package = self.__serialize_object(package)
        self.__put_package_to_queue((package, client_addr))

    def __check_clients_activity(self):
        inactive_clients = []
        for client in self.__connected_clients:
            if not client.is_user_active():
                inactive_clients.append(client)
        for client in inactive_clients:
            self.__remove_client(client)

    def __remove_client(self, client):
        print("Removing client...")
        client_character = client.get_client_character()
        self.__remove_character_from_chunk(client_character)
        self.__clients_characters.remove(client_character)
        self.__connected_clients.remove(client)

    def __check_stop(self):
        self.__stop_signal_lock.acquire()
        result = self.__stopped
        self.__stop_signal_lock.release()
        return result

    def __read_config(self):
        if os.path.isfile(self.__config_file):
            with open(self.__config_file) as json_file:
                config_file = json.load(json_file)
                self.__IP_ADDRESS = config_file['ipAddress']
                self.__PORT_NUMBER = config_file['portNumber']
                self.__MAX_HOSTS = config_file['maxHosts']
                self.__MAX_PACKAGE = config_file['maxPackage']
        else:
            self.__handle_config_from_console()

    def __handle_config_from_console(self):
        print('There is no config file for server! Pass me interface, port number and max hosts')
        self.__IP_ADDRESS = input('Enter host IP x.x.x.x: ')
        self.__PORT_NUMBER = int(input('Enter port number: '))
        self.__MAX_HOSTS = int(input('Enter max hosts to connect with: '))

    def __bind_socket(self):
        try:
            self.__socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.__socket.bind((self.__IP_ADDRESS, self.__PORT_NUMBER))
        except socket.error as msg:
            print(f'Failed binding specified interface {self.__IP_ADDRESS} and port {self.__PORT_NUMBER} error {msg}')
            sys.exit(error.WRONG_SOCKET)

    def __close_server(self):
        self.__inform_clients_about_close()
        self.__stop_receiving_thread()
        self.__stop_sending_thread()
        self.__db.close_connection()
        print("DEBUG end server thread")

    def __stop_receiving_thread(self):
        print(f'Stopping receiving thread...')
        self.__receiving_thread.stop()
        self.__receiving_thread.join(timeout=8)
        if self.__receiving_thread.isAlive():
            print('Receiving thread cannot be stopped')
        else:
            print("Receiving thread stopped")

    def __stop_sending_thread(self):
        print(f'Stopping sending thread...')
        self.__sending_thread.stop()
        self.__sending_thread.join(timeout=8)
        if self.__sending_thread.isAlive():
            print('Sending thread cannot be stopped')
        else:
            print("Sending thread stopped")

    def __inform_clients_about_close(self):
        self.__client_list_lock.acquire()
        print("Sending information to clients about closing server...")
        for client in self.__connected_clients:
            pass
        self.__client_list_lock.release()

    def __check_received_packages(self):
        if not self.__received_packages.empty():
            message = self.__received_packages.get()
            self.__handle_package(message)

    def check_user(self, address, key):
        for client in self.__connected_clients:
            if client.get_address() == address and client.get_auth_key() == key:
                client.update_last_received_time(time.time())
                return True
            elif client.get_address() == address and client.get_auth_key() != key:
                return False
        return False

    def __find_client_character(self, nick):
        for character in self.__clients_characters:
            if character.nick == nick:
                return character
        return None

    def find_client_by_character(self, character):
        for client in self.__connected_clients:
            if client.get_client_character() == character:
                return client

    def __create_new_character(self, nick):
        character = Character(self.__get_next_id(), nick, CHARACTER_START_HEALTH, CHARACTER_START_POSITION, [])
        self.__clients_characters.append(character)
        return character

    def find_chunk_index_by_position(self, position):
        pos_x, pos_y = position
        chunks_in_row = math.ceil(self.__map_width / CHUNK_WIDTH)
        chunk_index = int(pos_x / CHUNK_WIDTH) + int(pos_y / CHUNK_HEIGHT) * chunks_in_row
        return chunk_index

    def __add_character_to_chunk(self, character):
        chunk_index = self.find_chunk_index_by_position(character.position)
        self.__chunks_list[chunk_index].characters_list.append(character)
        print(f"Character added to chunk {chunk_index} at position: {self.__chunks_list[chunk_index].position}")

    def __remove_character_from_chunk(self, character):
        chunk_index = self.find_chunk_index_by_position(character.position)
        self.__chunks_list[chunk_index].characters_list.remove(character)
        print(f"Character removed from chunk {chunk_index} at position: {self.__chunks_list[chunk_index].position}")

    def add_client(self, nick, address, key):
        print("Adding new client...")
        client_character = self.__find_client_character(nick)
        if client_character is None:
            client_character = self.__create_new_character(nick)
        self.__add_character_to_chunk(client_character)
        client = Client(nick, address, key, client_character)
        self.__connected_clients.append(client)
        return client

    def __get_chunk_indexes_around(self, position):
        indexes = []
        character_chunk_index = self.find_chunk_index_by_position(position)
        character_chunk_position = self.__chunks_list[character_chunk_index].position
        for offset_x in (-CHUNK_WIDTH, 0, CHUNK_WIDTH):
            for offset_y in (-CHUNK_HEIGHT, 0, CHUNK_HEIGHT):
                chunk_pos_x = character_chunk_position[POS_X] + offset_x
                chunk_pos_y = character_chunk_position[POS_Y] + offset_y
                if 0 <= chunk_pos_x <= self.__map_width and 0 <= chunk_pos_y <= self.__map_height:
                    indexes.append(self.find_chunk_index_by_position((chunk_pos_x, chunk_pos_y)))
        return indexes

    def get_close_objects(self, character):
        close_objects = []
        chunk_indexes = self.__get_chunk_indexes_around(character.position)
        for index in chunk_indexes:
            for obj in self.__chunks_list[index].object_list:
                close_objects.append(obj)
        return close_objects

    def get_close_characters(self, character):
        close_characters = []
        chunk_indexes = self.__get_chunk_indexes_around(character.position)
        for index in chunk_indexes:
            for character in self.__chunks_list[index].characters_list:
                close_characters.append(character)
        return close_characters

    def __handle_package(self, package):
        print(package)
        package_to_send = self.__request_handler.handle_request(package)
        if package_to_send is None:
            return
        for package in package_to_send:
            self.__put_package_to_queue(package)

    def __put_package_to_queue(self, package):
        self.__packages_to_send.put(package)

    @staticmethod
    def __serialize_object(sending_object):
        return pickle.dumps(jsonpickle.encode(sending_object))
